{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});let _fs;try{_fs=require(\"graceful-fs\")}catch(_){_fs=require(\"fs\")}const universalify=require(\"universalify\");const{stringify,stripBom}=require(\"./utils\");async function _readFile(file,options={}){if(typeof options===\"string\"){options={encoding:options}}const fs=options.fs||_fs;const shouldThrow=\"throws\"in options?options.throws:true;let data=await universalify.fromCallback(fs.readFile)(file,options);data=stripBom(data);let obj;try{obj=JSON.parse(data,options?options.reviver:null)}catch(err){if(shouldThrow){err.message=`${file}: ${err.message}`;throw err}else{return null}}return obj}__name(_readFile,\"_readFile\");const readFile=universalify.fromPromise(_readFile);function readFileSync(file,options={}){if(typeof options===\"string\"){options={encoding:options}}const fs=options.fs||_fs;const shouldThrow=\"throws\"in options?options.throws:true;try{let content=fs.readFileSync(file,options);content=stripBom(content);return JSON.parse(content,options.reviver)}catch(err){if(shouldThrow){err.message=`${file}: ${err.message}`;throw err}else{return null}}}__name(readFileSync,\"readFileSync\");async function _writeFile(file,obj,options={}){const fs=options.fs||_fs;const str=stringify(obj,options);await universalify.fromCallback(fs.writeFile)(file,str,options)}__name(_writeFile,\"_writeFile\");const writeFile=universalify.fromPromise(_writeFile);function writeFileSync(file,obj,options={}){const fs=options.fs||_fs;const str=stringify(obj,options);return fs.writeFileSync(file,str,options)}__name(writeFileSync,\"writeFileSync\");const jsonfile={readFile,readFileSync,writeFile,writeFileSync};module.exports=jsonfile;\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HAAA,IAAI,IACJ,GAAI,CACF,IAAM,QAAQ,aAAa,CAC7B,OAAS,EAAP,CACA,IAAM,QAAQ,IAAI,CACpB,CACA,MAAM,aAAe,QAAQ,cAAc,EAC3C,KAAM,CAAE,UAAW,QAAS,EAAI,QAAQ,SAAS,EAEjD,eAAe,UAAW,KAAM,QAAU,CAAC,EAAG,CAC5C,GAAI,OAAO,UAAY,SAAU,CAC/B,QAAU,CAAE,SAAU,OAAQ,CAChC,CAEA,MAAM,GAAK,QAAQ,IAAM,IAEzB,MAAM,YAAc,WAAY,QAAU,QAAQ,OAAS,KAE3D,IAAI,KAAO,MAAM,aAAa,aAAa,GAAG,QAAQ,EAAE,KAAM,OAAO,EAErE,KAAO,SAAS,IAAI,EAEpB,IAAI,IACJ,GAAI,CACF,IAAM,KAAK,MAAM,KAAM,QAAU,QAAQ,QAAU,IAAI,CACzD,OAAS,IAAP,CACA,GAAI,YAAa,CACf,IAAI,QAAU,GAAG,SAAS,IAAI,UAC9B,MAAM,GACR,KAAO,CACL,OAAO,IACT,CACF,CAEA,OAAO,GACT,CA1Be,8BA4Bf,MAAM,SAAW,aAAa,YAAY,SAAS,EAEnD,SAAS,aAAc,KAAM,QAAU,CAAC,EAAG,CACzC,GAAI,OAAO,UAAY,SAAU,CAC/B,QAAU,CAAE,SAAU,OAAQ,CAChC,CAEA,MAAM,GAAK,QAAQ,IAAM,IAEzB,MAAM,YAAc,WAAY,QAAU,QAAQ,OAAS,KAE3D,GAAI,CACF,IAAI,QAAU,GAAG,aAAa,KAAM,OAAO,EAC3C,QAAU,SAAS,OAAO,EAC1B,OAAO,KAAK,MAAM,QAAS,QAAQ,OAAO,CAC5C,OAAS,IAAP,CACA,GAAI,YAAa,CACf,IAAI,QAAU,GAAG,SAAS,IAAI,UAC9B,MAAM,GACR,KAAO,CACL,OAAO,IACT,CACF,CACF,CArBS,oCAuBT,eAAe,WAAY,KAAM,IAAK,QAAU,CAAC,EAAG,CAClD,MAAM,GAAK,QAAQ,IAAM,IAEzB,MAAM,IAAM,UAAU,IAAK,OAAO,EAElC,MAAM,aAAa,aAAa,GAAG,SAAS,EAAE,KAAM,IAAK,OAAO,CAClE,CANe,gCAQf,MAAM,UAAY,aAAa,YAAY,UAAU,EAErD,SAAS,cAAe,KAAM,IAAK,QAAU,CAAC,EAAG,CAC/C,MAAM,GAAK,QAAQ,IAAM,IAEzB,MAAM,IAAM,UAAU,IAAK,OAAO,EAElC,OAAO,GAAG,cAAc,KAAM,IAAK,OAAO,CAC5C,CANS,sCAQT,MAAM,SAAW,CACf,SACA,aACA,UACA,aACF,EAEA,OAAO,QAAU","names":[],"sources":["/root/porla/front-end-mergeVersion/fantastic-admin.v2.11.0/node_modules/.pnpm/jsonfile@6.1.0/node_modules/jsonfile/index.js"],"sourcesContent":["let _fs\ntry {\n  _fs = require('graceful-fs')\n} catch (_) {\n  _fs = require('fs')\n}\nconst universalify = require('universalify')\nconst { stringify, stripBom } = require('./utils')\n\nasync function _readFile (file, options = {}) {\n  if (typeof options === 'string') {\n    options = { encoding: options }\n  }\n\n  const fs = options.fs || _fs\n\n  const shouldThrow = 'throws' in options ? options.throws : true\n\n  let data = await universalify.fromCallback(fs.readFile)(file, options)\n\n  data = stripBom(data)\n\n  let obj\n  try {\n    obj = JSON.parse(data, options ? options.reviver : null)\n  } catch (err) {\n    if (shouldThrow) {\n      err.message = `${file}: ${err.message}`\n      throw err\n    } else {\n      return null\n    }\n  }\n\n  return obj\n}\n\nconst readFile = universalify.fromPromise(_readFile)\n\nfunction readFileSync (file, options = {}) {\n  if (typeof options === 'string') {\n    options = { encoding: options }\n  }\n\n  const fs = options.fs || _fs\n\n  const shouldThrow = 'throws' in options ? options.throws : true\n\n  try {\n    let content = fs.readFileSync(file, options)\n    content = stripBom(content)\n    return JSON.parse(content, options.reviver)\n  } catch (err) {\n    if (shouldThrow) {\n      err.message = `${file}: ${err.message}`\n      throw err\n    } else {\n      return null\n    }\n  }\n}\n\nasync function _writeFile (file, obj, options = {}) {\n  const fs = options.fs || _fs\n\n  const str = stringify(obj, options)\n\n  await universalify.fromCallback(fs.writeFile)(file, str, options)\n}\n\nconst writeFile = universalify.fromPromise(_writeFile)\n\nfunction writeFileSync (file, obj, options = {}) {\n  const fs = options.fs || _fs\n\n  const str = stringify(obj, options)\n  // not sure if fs.writeFileSync returns anything, but just in case\n  return fs.writeFileSync(file, str, options)\n}\n\nconst jsonfile = {\n  readFile,\n  readFileSync,\n  writeFile,\n  writeFileSync\n}\n\nmodule.exports = jsonfile\n"]}}