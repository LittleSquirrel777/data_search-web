{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const u=require(\"universalify\").fromPromise;const fs=require(\"../fs\");const path=require(\"path\");const mkdir=require(\"../mkdirs\");const remove=require(\"../remove\");const emptyDir=u(__name(async function emptyDir2(dir){let items;try{items=await fs.readdir(dir)}catch{return mkdir.mkdirs(dir)}return Promise.all(items.map(item=>remove.remove(path.join(dir,item))))},\"emptyDir\"));function emptyDirSync(dir){let items;try{items=fs.readdirSync(dir)}catch{return mkdir.mkdirsSync(dir)}items.forEach(item=>{item=path.join(dir,item);remove.removeSync(item)})}__name(emptyDirSync,\"emptyDirSync\");module.exports={emptyDirSync,emptydirSync:emptyDirSync,emptyDir,emptydir:emptyDir};\n})()\n","warnings":[],"map":{"version":3,"mappings":";+HAEA,MAAM,EAAI,QAAQ,cAAc,EAAE,YAClC,MAAM,GAAK,QAAQ,OAAO,EAC1B,MAAM,KAAO,QAAQ,MAAM,EAC3B,MAAM,MAAQ,QAAQ,WAAW,EACjC,MAAM,OAAS,QAAQ,WAAW,EAElC,MAAM,SAAW,EAAE,sBAAeA,UAAU,IAAK,CAC/C,IAAI,MACJ,GAAI,CACF,MAAQ,MAAM,GAAG,QAAQ,GAAG,CAC9B,MAAE,CACA,OAAO,MAAM,OAAO,GAAG,CACzB,CAEA,OAAO,QAAQ,IAAI,MAAM,IAAI,MAAQ,OAAO,OAAO,KAAK,KAAK,IAAK,IAAI,CAAC,CAAC,CAAC,CAC3E,EATmB,WASlB,EAED,SAAS,aAAc,IAAK,CAC1B,IAAI,MACJ,GAAI,CACF,MAAQ,GAAG,YAAY,GAAG,CAC5B,MAAE,CACA,OAAO,MAAM,WAAW,GAAG,CAC7B,CAEA,MAAM,QAAQ,MAAQ,CACpB,KAAO,KAAK,KAAK,IAAK,IAAI,EAC1B,OAAO,WAAW,IAAI,CACxB,CAAC,CACH,CAZS,oCAcT,OAAO,QAAU,CACf,aACA,aAAc,aACd,SACA,SAAU,QACZ","names":["emptyDir"],"sources":["/root/porla/data_system-web/node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/empty/index.js"],"sourcesContent":["'use strict'\n\nconst u = require('universalify').fromPromise\nconst fs = require('../fs')\nconst path = require('path')\nconst mkdir = require('../mkdirs')\nconst remove = require('../remove')\n\nconst emptyDir = u(async function emptyDir (dir) {\n  let items\n  try {\n    items = await fs.readdir(dir)\n  } catch {\n    return mkdir.mkdirs(dir)\n  }\n\n  return Promise.all(items.map(item => remove.remove(path.join(dir, item))))\n})\n\nfunction emptyDirSync (dir) {\n  let items\n  try {\n    items = fs.readdirSync(dir)\n  } catch {\n    return mkdir.mkdirsSync(dir)\n  }\n\n  items.forEach(item => {\n    item = path.join(dir, item)\n    remove.removeSync(item)\n  })\n}\n\nmodule.exports = {\n  emptyDirSync,\n  emptydirSync: emptyDirSync,\n  emptyDir,\n  emptydir: emptyDir\n}\n"]}}