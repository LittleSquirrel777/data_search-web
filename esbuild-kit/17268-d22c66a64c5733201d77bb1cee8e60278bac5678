{"code":"(()=>{\n\"use strict\";var __defProp=Object.defineProperty;var __name=(target,value)=>__defProp(target,\"name\",{value,configurable:true});const fs=require(\"../fs\");const path=require(\"path\");const util=require(\"util\");function getStats(src,dest,opts){const statFunc=opts.dereference?file=>fs.stat(file,{bigint:true}):file=>fs.lstat(file,{bigint:true});return Promise.all([statFunc(src),statFunc(dest).catch(err=>{if(err.code===\"ENOENT\")return null;throw err})]).then(([srcStat,destStat])=>({srcStat,destStat}))}__name(getStats,\"getStats\");function getStatsSync(src,dest,opts){let destStat;const statFunc=opts.dereference?file=>fs.statSync(file,{bigint:true}):file=>fs.lstatSync(file,{bigint:true});const srcStat=statFunc(src);try{destStat=statFunc(dest)}catch(err){if(err.code===\"ENOENT\")return{srcStat,destStat:null};throw err}return{srcStat,destStat}}__name(getStatsSync,\"getStatsSync\");function checkPaths(src,dest,funcName,opts,cb){util.callbackify(getStats)(src,dest,opts,(err,stats)=>{if(err)return cb(err);const{srcStat,destStat}=stats;if(destStat){if(areIdentical(srcStat,destStat)){const srcBaseName=path.basename(src);const destBaseName=path.basename(dest);if(funcName===\"move\"&&srcBaseName!==destBaseName&&srcBaseName.toLowerCase()===destBaseName.toLowerCase()){return cb(null,{srcStat,destStat,isChangingCase:true})}return cb(new Error(\"Source and destination must not be the same.\"))}if(srcStat.isDirectory()&&!destStat.isDirectory()){return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`))}if(!srcStat.isDirectory()&&destStat.isDirectory()){return cb(new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`))}}if(srcStat.isDirectory()&&isSrcSubdir(src,dest)){return cb(new Error(errMsg(src,dest,funcName)))}return cb(null,{srcStat,destStat})})}__name(checkPaths,\"checkPaths\");function checkPathsSync(src,dest,funcName,opts){const{srcStat,destStat}=getStatsSync(src,dest,opts);if(destStat){if(areIdentical(srcStat,destStat)){const srcBaseName=path.basename(src);const destBaseName=path.basename(dest);if(funcName===\"move\"&&srcBaseName!==destBaseName&&srcBaseName.toLowerCase()===destBaseName.toLowerCase()){return{srcStat,destStat,isChangingCase:true}}throw new Error(\"Source and destination must not be the same.\")}if(srcStat.isDirectory()&&!destStat.isDirectory()){throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`)}if(!srcStat.isDirectory()&&destStat.isDirectory()){throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`)}}if(srcStat.isDirectory()&&isSrcSubdir(src,dest)){throw new Error(errMsg(src,dest,funcName))}return{srcStat,destStat}}__name(checkPathsSync,\"checkPathsSync\");function checkParentPaths(src,srcStat,dest,funcName,cb){const srcParent=path.resolve(path.dirname(src));const destParent=path.resolve(path.dirname(dest));if(destParent===srcParent||destParent===path.parse(destParent).root)return cb();fs.stat(destParent,{bigint:true},(err,destStat)=>{if(err){if(err.code===\"ENOENT\")return cb();return cb(err)}if(areIdentical(srcStat,destStat)){return cb(new Error(errMsg(src,dest,funcName)))}return checkParentPaths(src,srcStat,destParent,funcName,cb)})}__name(checkParentPaths,\"checkParentPaths\");function checkParentPathsSync(src,srcStat,dest,funcName){const srcParent=path.resolve(path.dirname(src));const destParent=path.resolve(path.dirname(dest));if(destParent===srcParent||destParent===path.parse(destParent).root)return;let destStat;try{destStat=fs.statSync(destParent,{bigint:true})}catch(err){if(err.code===\"ENOENT\")return;throw err}if(areIdentical(srcStat,destStat)){throw new Error(errMsg(src,dest,funcName))}return checkParentPathsSync(src,srcStat,destParent,funcName)}__name(checkParentPathsSync,\"checkParentPathsSync\");function areIdentical(srcStat,destStat){return destStat.ino&&destStat.dev&&destStat.ino===srcStat.ino&&destStat.dev===srcStat.dev}__name(areIdentical,\"areIdentical\");function isSrcSubdir(src,dest){const srcArr=path.resolve(src).split(path.sep).filter(i=>i);const destArr=path.resolve(dest).split(path.sep).filter(i=>i);return srcArr.reduce((acc,cur,i)=>acc&&destArr[i]===cur,true)}__name(isSrcSubdir,\"isSrcSubdir\");function errMsg(src,dest,funcName){return`Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`}__name(errMsg,\"errMsg\");module.exports={checkPaths,checkPathsSync,checkParentPaths,checkParentPathsSync,isSrcSubdir,areIdentical};\n})()\n","warnings":[],"map":{"version":3,"mappings":"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","names":[],"sources":["/root/porla/data_system-web/node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/util/stat.js"],"sourcesContent":["'use strict'\n\nconst fs = require('../fs')\nconst path = require('path')\nconst util = require('util')\n\nfunction getStats (src, dest, opts) {\n  const statFunc = opts.dereference\n    ? (file) => fs.stat(file, { bigint: true })\n    : (file) => fs.lstat(file, { bigint: true })\n  return Promise.all([\n    statFunc(src),\n    statFunc(dest).catch(err => {\n      if (err.code === 'ENOENT') return null\n      throw err\n    })\n  ]).then(([srcStat, destStat]) => ({ srcStat, destStat }))\n}\n\nfunction getStatsSync (src, dest, opts) {\n  let destStat\n  const statFunc = opts.dereference\n    ? (file) => fs.statSync(file, { bigint: true })\n    : (file) => fs.lstatSync(file, { bigint: true })\n  const srcStat = statFunc(src)\n  try {\n    destStat = statFunc(dest)\n  } catch (err) {\n    if (err.code === 'ENOENT') return { srcStat, destStat: null }\n    throw err\n  }\n  return { srcStat, destStat }\n}\n\nfunction checkPaths (src, dest, funcName, opts, cb) {\n  util.callbackify(getStats)(src, dest, opts, (err, stats) => {\n    if (err) return cb(err)\n    const { srcStat, destStat } = stats\n\n    if (destStat) {\n      if (areIdentical(srcStat, destStat)) {\n        const srcBaseName = path.basename(src)\n        const destBaseName = path.basename(dest)\n        if (funcName === 'move' &&\n          srcBaseName !== destBaseName &&\n          srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {\n          return cb(null, { srcStat, destStat, isChangingCase: true })\n        }\n        return cb(new Error('Source and destination must not be the same.'))\n      }\n      if (srcStat.isDirectory() && !destStat.isDirectory()) {\n        return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`))\n      }\n      if (!srcStat.isDirectory() && destStat.isDirectory()) {\n        return cb(new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`))\n      }\n    }\n\n    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n      return cb(new Error(errMsg(src, dest, funcName)))\n    }\n    return cb(null, { srcStat, destStat })\n  })\n}\n\nfunction checkPathsSync (src, dest, funcName, opts) {\n  const { srcStat, destStat } = getStatsSync(src, dest, opts)\n\n  if (destStat) {\n    if (areIdentical(srcStat, destStat)) {\n      const srcBaseName = path.basename(src)\n      const destBaseName = path.basename(dest)\n      if (funcName === 'move' &&\n        srcBaseName !== destBaseName &&\n        srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {\n        return { srcStat, destStat, isChangingCase: true }\n      }\n      throw new Error('Source and destination must not be the same.')\n    }\n    if (srcStat.isDirectory() && !destStat.isDirectory()) {\n      throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`)\n    }\n    if (!srcStat.isDirectory() && destStat.isDirectory()) {\n      throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`)\n    }\n  }\n\n  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n    throw new Error(errMsg(src, dest, funcName))\n  }\n  return { srcStat, destStat }\n}\n\n// recursively check if dest parent is a subdirectory of src.\n// It works for all file types including symlinks since it\n// checks the src and dest inodes. It starts from the deepest\n// parent and stops once it reaches the src parent or the root path.\nfunction checkParentPaths (src, srcStat, dest, funcName, cb) {\n  const srcParent = path.resolve(path.dirname(src))\n  const destParent = path.resolve(path.dirname(dest))\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return cb()\n  fs.stat(destParent, { bigint: true }, (err, destStat) => {\n    if (err) {\n      if (err.code === 'ENOENT') return cb()\n      return cb(err)\n    }\n    if (areIdentical(srcStat, destStat)) {\n      return cb(new Error(errMsg(src, dest, funcName)))\n    }\n    return checkParentPaths(src, srcStat, destParent, funcName, cb)\n  })\n}\n\nfunction checkParentPathsSync (src, srcStat, dest, funcName) {\n  const srcParent = path.resolve(path.dirname(src))\n  const destParent = path.resolve(path.dirname(dest))\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return\n  let destStat\n  try {\n    destStat = fs.statSync(destParent, { bigint: true })\n  } catch (err) {\n    if (err.code === 'ENOENT') return\n    throw err\n  }\n  if (areIdentical(srcStat, destStat)) {\n    throw new Error(errMsg(src, dest, funcName))\n  }\n  return checkParentPathsSync(src, srcStat, destParent, funcName)\n}\n\nfunction areIdentical (srcStat, destStat) {\n  return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev\n}\n\n// return true if dest is a subdir of src, otherwise false.\n// It only checks the path strings.\nfunction isSrcSubdir (src, dest) {\n  const srcArr = path.resolve(src).split(path.sep).filter(i => i)\n  const destArr = path.resolve(dest).split(path.sep).filter(i => i)\n  return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true)\n}\n\nfunction errMsg (src, dest, funcName) {\n  return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`\n}\n\nmodule.exports = {\n  checkPaths,\n  checkPathsSync,\n  checkParentPaths,\n  checkParentPathsSync,\n  isSrcSubdir,\n  areIdentical\n}\n"]}}